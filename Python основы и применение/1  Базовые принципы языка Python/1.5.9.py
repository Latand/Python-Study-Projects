#
#
#
# Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой последовательности, затем сумму второй пятерки, и т. д.
# Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. Например, сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.
# Реализуйте класс Buffer, который будет накапливать в себе элементы последовательности и выводить сумму пятерок последовательных элементов по мере их накопления.
# Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.
#
# Класс должен иметь следующий вид


class Buffer:

    def __init__(self):
        self.arr = []
        # конструктор без аргументов

    def add(self, *a):
        for arg in a:
            if len(self.arr) < 4:
                self.arr.append(arg)
            else:
                self.arr.append(arg)
                print(sum(self.arr))
                self.arr = []

    # добавить следующую часть последовательности

    def get_current_part(self):
        return self.arr
        # вернуть сохраненные в текущий момент элементы последовательности в порядке, в котором они были
        # добавлены

#
# Пример правильного решения:
#
# Атрибут self.part - - хранит текущее состояние нашего буфера.Внутри метода add после
# добавления
# каждого
# элемента, проверяем
# длину
# текущего
# состоянии
# нашего
# буфера: если
# длина
# стала
# равно
# 5 - - выводим
# на
# экран
# сумму
# элементов
# в
# буфере
# и
# не
# забываем
# чистить
# буфер.
#
#
# class Buffer:
#     def __init__(self):
#         self.part = []
#
#     def add(self, *a):
#         for i in a:
#             self.part.append(i)
#             if len(self.part) == 5:
#                 print(sum(self.part))
#                 self.part.clear()
#
#     def get_current_part(self):
#         return self.part

#
# class Buffer:
#     def __init__(self):
#         # конструктор без аргументов
#         self.value = []
#
#     def add(self, *a):
#         # добавить следующую часть последовательности.
#         # просто увеличим наш список 'value'
#         # на величину кортежа 'a', Python просто чудо!
#         self.value += a
#         while len(self.value) >= 5:
#             # суммируем первые 5 элементов, это
#             # так просто! красота!
#             print(sum(self.value[0:5]))
#             # переприсваиваем в атрибут списка 'value'
#             # все его же элементы после 5-го!
#             self.value = self.value[5:]
#             # интересно, что сделает интерпретатор
#             # со старым значением в памяти после
#             # переприсваивания?
#
#     def get_current_part(self):
#         # вернуть сохраненные в текущий момент
#         # элементы последовательности в порядке,
#         # в котором они были добавлены
#         return self.value
