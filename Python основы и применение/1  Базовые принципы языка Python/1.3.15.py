# Сочетанием из n элементов по k называется подмножество этих n элементов размера k.
# Два сочетания называются различными, если одно из сочетаний содержит элемент, который не содержит другое.
# Числом сочетаний из n по k называется количество различных сочетаний из n по k. Обозначим это число за C(n, k).
#
# Пример:
# Пусть n = 3, т. е. есть три элемента (1, 2, 3). Пусть k = 2.
# Все различные сочетания из 3 элементов по 2: (1, 2), (1, 3), (2, 3).
# Различных сочетаний три, поэтому C(3, 2) = 3.
#
# Несложно понять, что C(n, 0) = 1, так как из n элементов выбрать 0 можно единственным образом, а именно, ничего не выбрать.
# Также несложно понять, что если k > n, то C(n, k) = 0, так как невозможно, например, из трех элементов выбрать пять.
# Для вычисления C(n, k) в других случаях используется следующая рекуррентная формула:
# C(n, k) = C(n - 1, k) + C(n - 1, k - 1).
#
# Реализуйте программу, которая для заданных n и k вычисляет C(n, k).
# Вашей программе на вход подается строка, содержащая два целых числа n и k (1 ≤ n ≤ 10, 0 ≤ k ≤ 10).
# Ваша программа должна вывести единственное число: C(n, k).
#
# Примечание:
# Считать два числа n и k вы можете, например, следующим образом:
# n, k = map(int, input().split())

n, k = map(int, input().split())


def comb_elem(a, b):
    if b == 0:
        return 1
    elif b > a:
        return 0
    else:
        return comb_elem(a - 1, b) + comb_elem(a - 1, b - 1)


print(comb_elem(n, k))


# Пример эффективного решения, где все значения считаются только 1 раз:
# n, k = map(int, input().split())
#
# sz = max(n, k) + 1
# c = [[0] * sz for _ in range(sz)]
#
# c[0][0] = 1
# for i in range(1, sz):
#     for j in range(i + 1):
#         c[i][j] = c[i - 1][j] + c[i - 1][j - 1]
#
# print(c[n][k])


# Пример правильного решения через рекурсивную функцию
# def c(n, k):
#     if k > n:
#         return 0
#     if k == 0:
#         return 1
#     return c(n - 1, k) + c(n - 1, k - 1)
#
# n, k = map(int, input().split())
# print(c(n, k))


# Пример с операторами в условиях
# def cnk(n, k):
#     return cnk(n - 1, k) + cnk(n - 1, k - 1) if k != 0 and k <= n else  1 if k == 0 else  0
#
# print(cnk(*map(int, input().split())))
